# Day 2: Python 기초

## 리스트 

List: 여러 개의 값을 순서대로 저장하는, 변경 가능한(mutalbe) 시퀀스 자료형

### 리스트 표현
- 대괄호 `[]` 안에 값들을 쉼표 `,`로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경 가능

```python
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
````

### 시퀀스로서의 리스트

리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

```python
my_list = [1, 'a', 3, 'b', 5]

# 인덱싱
print(my_list[1])  # a

# 슬라이싱
print(my_list[::-1])  # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list))  # 5
```

## 중첩리스트 (Nested List)

다른 리스트를 값으로 가진 리스트

### 중첩리스트 접근하기
- 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음
- 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
- 선택된 안쪽 리스트에 다시 한번 인덱스를 사용

```python
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
print(my_list[-1][1][0])  # w
print(my_list[4][-1])     # !!!
print(len(my_list))       # 5
```

## 리스트의 가변성

한 번 생성된 리스트는 그 내용을 자유롭게 수정, 추가, 삭제할 수 있음 (문자열의 불변성과 반대)

```python
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]

my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 'two', 'three', 'four', 5]
```

---

## 튜플 (Tuple)

여러 개의 값을 순서대로 저장하는 **변경 불가능한(Immutable)** 시퀀스 자료형

### 튜플 표현
- 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음
- 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
- 선택된 안쪽 리스트에 다시 한번 인덱스를 사용

```python
my_tuple_1 = ()
my_tuple_2 = (1,)
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```

* 소괄호 없이도 생성 가능
* 단일 요소일 경우 반드시 후행 쉼표 필요 (`(1,)`)

### 시퀀스로서의 튜플
- 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

```python
my_tuple = (1, 'a', 3, 'b', 5)

# 인덱싱
print(my_tuple[1])  # a

# 슬라이싱
print(my_tuple[::-1])  # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_tuple))  # 5
```

### 튜플의 불변성
- 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음

```python
my_tuple = (1, 'a', 3, 'b', 5)
my_tuple[1] = 'z'  # TypeError 발생
```

- 함수 다중 반환, 값 교환 등에서 주로 간접적으로 사용됨
- 데이터의 안정성과 무결성을 보장

---

## 레인지 (Range)

연속된 정수 시퀀스를 생성하는, **변경 불가능한(Immutable)** 자료형

- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용

### 기본구문 
- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있다.
- range(start, stop, step) #엄밀히 함수, 반복문과 같이 사용
- 매개변수: 함수를 정의할 때, 함수가 받을 값을 나타내는 변수
- 인자: 함수를 호출할 때, 실제로 전달되는 값

```python
range(n) # 0 ~ n-1
range(start, stop)
range(start, stop, step)
```

```python
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

# list형태로 출력
print(list(my_range_1))  # [0, 1, 2, 3, 4]
print(list(my_range_2))  # [1, ..., 9]
print(list(my_range_3))  # [5, 4, 3, 2, 1]
```

range(stop) 
- 매개변수가 하나면 stop으로 인식
- Start는 0이, Step은 1이 기본값으로 자동 설정
- range(5) -> 0, 1, 2, 3, 4

range(start, stop) 
- 매개변수가 두 개면 Start, Stop으로 인식
- Step은 1이 기본값으로 자동설정
- range(2, 5) -> 2, 3, 4

range(start, stop, step) 
- 모든 매개변수를 직접 지정
- range(2, 10, 2) -> 2, 4, 6, 8

stop 값은 생성되는 시퀀스에 (n-1)까지 생성되어 포함하지 않음

step 값은 숫자 시퀀스의 간격과 방향을 결정

```python
if(Step == 1):
    print('오름차순')
elif(Step == -1):
    print('내림차순')
```

---

## 딕셔너리 (Dictionary)

Key - Value 쌍으로 이루어진 **순서 없고 중복 없는 변경 가능한(Mutable)** 자료형

### 딕셔너리 표현현
- 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- Key(키): 값을 식별하기 위한 고유한 '이름표' 중복 불가
- Value(값): 키에 해당하는 실제 데이터
- 각 값에는 순서가 없음
- Python 3.7 이상부터 Input 순서대로 Output이 유지,보장  / But, 순서가 있는게 아님! Key를 통한 접근이라는 점! 

- Key는 고유하고 immutable 자료형이어야 함
- Value는 어떤 자료형이든 가능

### 딕셔너리 값 접근 
- Key를 사용하여 해당 Value를 꺼내 올 수 있음
- Key에 접근 시 대괄호 [] 사용

```python
my_dict = {'name': '홍길동', 'age': 25}
print(my_dict['name'])  # 홍길동

# 값 추가 및 변경
my_dict['banana'] = 50
my_dict['apple'] = 100
```

---

## 세트 (Set)

순서와 중복이 없는 **변경 가능한(Mutable)** 자료형

### Set 표현
- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능

### Set 두 가지 핵심
- 중복을 허용하지 않음: 똑같은 값은 단 하나만 존재할 수 있음
- 순서가 없음: 인덱싱(set[0]), 슬라이싱(set[0:2])을 사용할 수 없음
- 비어있는 딕셔너리와 혼동을 피하기 위해 비어있는 세트는 초기 선언 필요! 

```python
my_set = {1, 2, 3}
empty_set = set()
```

### 집합 연산

- 수학의 '집합' 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적 

```python
a = {1, 2, 3}
b = {3, 6, 9}

print(a | b)  # 합집합
print(a - b)  # 차집합
print(a & b)  # 교집합
```

---

## 이외 주요 타입

* **None**: 값이 없음
* **Boolean**: True / False
* **Collection**: str, list, tuple, dict, set, range 등

---

## 컬렉션 정리

| 컬렉션명  | 변경 가능 | 순서 있음 | 비고   |
| ----- | ----- | ----- | ---- |
| str   | X     | O     | 시퀀스  |
| list  | O     | O     | 시퀀스  |
| tuple | X     | O     | 시퀀스  |
| dict  | O     | X     | 비시퀀스 |
| set   | O     | X     | 비시퀀스 |

---

## 불변 vs 가변

컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변' 

| 구분 | 불변 (Immutable)    | 가변 (Mutable)    |
| -- | ----------------- | --------------- |
| 특징 | 변경 불가             | 변경 가능           |
| 예시 | str, tuple, range | list, dict, set |

---

## 형변환(Type Conversion)

한 데이터 타입을 다른 데이터 타입으로 변환하는 과정

### 암시적 형변환(Implicit Conversion)

파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것

- 암시적 형변환은 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙

```python
print(3 + 5.0)        # 8.0
print(True + 3)       # 4
print(True + False)   # 1
```

### 명시적 형변환(Explicit Conversion)

개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것

- 명시적 형변환은 서로 다른 타입의 데이터를 '호환'되도록 맞추는 과정

| 함수      | 예시            | 결과             |
| ------- | ------------- | -------------- |
| int()   | int("123")    | 123            |
| float() | float("3.14") | 3.14           |
| str()   | str(100)      | "100"          |
| list()  | list("abc")   | \['a','b','c'] |
| tuple() | tuple(\[1,2]) | (1,2)          |
| set()   | set(\[1,2,2]) | {1,2}          |

---

## 연산자

### 산술 연산자

| 연산자  | 설명     |
| ---- | ------ |
| +    | 덧셈     |
| -    | 뺄셈     |
| \*   | 곱셈     |
| /    | 나눗셈    |
| //   | 정수 나눗셈 |
| %    | 나머지    |
| \*\* | 거듭제곱   |

---

### 복합 연산자

| 연산자    | 의미         |기호   |
| --------- | ------------ | ----- |
| a += b    | a = a + b    | '+='  |
| a -= b    | a = a - b    | '-='  |
| a *= b    | a = a * b    | '*='  |
| a /= b    | a = a / b    | '/='  |
| a //= b   | a = a // b   | '//=' |
| a %= b    | a = a % b    | '%='  |
| a **= b   | a = a ** b   | '**=' |

---

### 비교 연산자

| 연산자          | 의미     |
| ------------ | ------ |
| <, <=, >, >= | 비교     |
| ==           | 동등성(값) |
| !=           | 불일치    |
| is           | 객체 동일성 |
| is not       | 객체 불일치 |

---

## == 연산자
* 값(데이터)이 같은지 비교
* 동등성(Equality)
* print( 1 == True ) # 암시적 형변환으로 True를 1로 간주
*  ==(Equality Operator):
   - 두 변수가 가리키는 객체의 내용, 즉 '값(Value)'이 같은지를 확인

## is 연산자
* 객체(값 + 주소) 자체가 같은지 비교
* 식별성(Identity)
* 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지 확인할 때 사용 literal: 표현법
* is(Identity Operator): 
    - 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지, 즉 '정체성(Identity)'이 같은지 확인

## == vs is

is는 '정체성'을 ==는 '가치'를 비교
* 두 연산자는 "같다"를 확인하는 목적이 근본적으로 다름
* 값의 비교는 '두 객체의 값이 논리적으로 같은가?'의도이므로 == 사용!

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)  # True
print(a is b)  # False

b = a
print(a is b)  # True
```

* `==`: 값 비교 (Equality)
* `is`: 객체 비교 (Identity)

---

## 싱글턴(Singleton) 객체

* 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체
* 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함꼐 가리키게 되므로 항상 같은 메모리 주소를 가짐 
* 전역에서 하나만 존재하는 객체: `None`, `True`, `False`
* 비교 시 `is` 사용 권장

```python
# 둘다 작동은 되지만 싱글턴 객체 비교엔 is 권장!
x = None 
if x is None:
    print('x는 None입니다.')

if x == None:
    print('x는 None입니다.')

# 가변 객체(mutable) 비교에 값 자체 비교는 ==, 동일한 객체 확인은 is
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b) # True (두 리스트의 값은 동일)
print(a is b) # False (서로 다른 리스트 객체)

b = a
print(a is b) # True (같은 객체를 가리키므로 True)
```

---

## 논리 연산자

| 연산자 | 의미   |
| --- | ---- |
| and | 논리곱  |
| or  | 논리합  |
| not | 논리부정 |

---

## 단축 평가 (Short-circuit)

논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
* 꼭 필요한 계산만 하고, 결과가 이미 정해졌다면 이후 피연산자는 확인하지 않음

False: Flase, 숫자 0, 빈 문자열 " ", 빈 리스트 [], None 등 '비어있거나 없다'에 값들

* `and`: 하나라도 False면 즉시 False
* `or`: 하나라도 True면 즉시 True

### 단축 평가를 하는 이유
* 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함
* 단순히 True / False 논리 연산을 넘어, 코드 흐름을 제어하고 오류를 방지하며 간결한 코드를 작성하는 데 유용하게 사용

---

## 멤버십 연산자

특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

| 연산자    | 설명     |
| ------ | ------ |
| in     | 포함 여부  |
| not in | 미포함 여부 |

---

## 시퀀스 연산자

시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자

| 연산자 | 설명 |
| ----- | ---- |
| +   | 연결 연산자 |
| \*  | 반복 연산자|

---

## 연산자 우선순위

| 우선순위 | 연산자 | 내용 | 
| ---- |  --- | ---- |
| 높음 | ()  | 소괄호, Grouping
|      | [] | 인덱싱, 슬라이싱
|      | ** | 거듭제곱
|      | +, - | 단항 연산자 양수/음수
|      | *, /, //, % | 산술 연산자
|      | +, - | 산술 연산자
|      | <, <=, >, >=, ==, != | 비교 연산자
|      | is, is not | 객체 비교
|      | in, not in | 맴버십 연산자
|      | not | 논리 부정
|      | and | 논리 AND
| 낮음 | or | 논리 OR

---

## Trailing Comma

컬렉션의 마지막 요소 뒤에 붙는 쉼표

```python
items = [
    'item1',
    'item2',
]
```

* 마지막 요소 뒤에 쉼표 추가
* 가독성 향상
* 단일 요소 튜플 `(1,)`에는 필수

장점
* 가독성 향상: 동일한 패턴을 가지고 코드 리뷰가 용이
* 유지보수 용이: 항목 추가/제거가 간단하며 실수로 구문 오류를 방지

## 복사의 개념: 얕은 복사 vs 깊은 복사

Python에서 컬렉션 자료형(`list`, `dict` 등)을 복사할 때는 단순한 `=` 할당, `copy()`, `deepcopy()` 등 방법에 따라 동작이 달라진다.

---

### 얕은 복사 (Shallow Copy)

- **외부 객체만 새로 생성되며**, 내부에 포함된 중첩 객체는 **원본과 동일한 참조를 공유한다**.
- 즉, **바깥 구조는 복사되지만, 내부 요소들은 같은 객체를 가리킨다**.

```python
import copy

original = [1, [2, 3]]
shallow = copy.copy(original)

shallow[0] = 100
print(original)  # [1, [2, 3]]
print(shallow)   # [100, [2, 3]]

shallow[1][0] = 999
print(original)  # [1, [999, 3]] ← 내부 요소도 함께 변경된다
````

> `list.copy()`나 슬라이싱(`[:]`)도 얕은 복사에 해당한다.

```python
a = [[1, 2], [3, 4]]
b = a[:]  # 얕은 복사

b[0][0] = 100
print(a)  # [[100, 2], [3, 4]]
```

---

### 깊은 복사 (Deep Copy)

* **외부 객체뿐 아니라 내부에 포함된 모든 객체까지 재귀적으로 복사한다**.
* 복사본과 원본은 완전히 독립적이며, 한쪽의 변경이 다른 쪽에 영향을 주지 않는다.

```python
import copy

original = [1, [2, 3]]
deep = copy.deepcopy(original)

deep[1][0] = 999
print(original)  # [1, [2, 3]] ← 원본 그대로 유지된다
print(deep)      # [1, [999, 3]]
```

---

### 얕은 복사 vs 깊은 복사 비교

| 구분    | 복사 범위        | 내부 객체 공유 여부 | 안전성   | 메모리 사용 |
| ----- | ------------ | ----------- | ----- | ------ |
| `=`   | 참조만 복사한다     | O (동일 객체)   | 매우 낮다 | 없음     |
| 얕은 복사 | 외부 객체만 복사한다  | O           | 보통이다  | 적다     |
| 깊은 복사 | 내부까지 전부 복사한다 | X           | 높다    | 많다     |

---

### 복사 방법 요약

| 방법                 | 설명                   |
| ------------------ | -------------------- |
| `a.copy()`         | 얕은 복사를 수행한다          |
| `copy.copy(a)`     | 얕은 복사를 수행한다          |
| `copy.deepcopy(a)` | 깊은 복사를 수행한다          |
| `a[:]`             | 얕은 복사를 수행한다 (리스트 한정) |

---

> 중첩 구조가 없는 단순 리스트는 얕은 복사로 충분하다.
> 리스트 안에 리스트, 딕셔너리 안에 딕셔너리 등 **중첩된 구조**에서는 `deepcopy()`를 사용하는 것이 안전하다.


