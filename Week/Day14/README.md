# Day 14: String

## 문자열
### 코드체계

**컴퓨터에서의 문자표현**

코드체계: 문자에 대응되는 숫자를 정한 것

> 메모리는 숫자만을 저장 가능
> 영어 대소문자 합쳐서 52자 이므로(64가지 경우)면 저장가능
> 예를들어 'a' -> 000000(0), 'b' -> 000001(0) 같이 6비트 이진수(10진수)를 배정함

**코트체계의 문제**

- 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해 놓고 사용
- 네트워크가 발전하면서 서로 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생김

**코드체계의 개선**

- 혼동을 피하기 위해 표준안을 만들기로 함
- 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정
- ASCII는 7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어짐

**출력 가능 아스키 문자**

![아스키]()

**확장 아스키**

Extended ASCII: 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가

- 표준 ASCII는 7-bit를 사용하여 문자를 표현, 확장 ASCII는 1Byte 내의 8-bit를 모두 사용함으로써 추가적인 문자를 표현
- 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있고, 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못함
- 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있음

**확장 아스키 예**

![확장아스키]()

**유니코드**

- 컴퓨터가 발전하면서 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 됨
    - 우리나라도 한글 코드체계를 만들어 사용하고 조합형, 완성형 두 종류를 가지고 있음

- 인터넷이 전세계로 발전하면서 ASCII를 만들기 전과 같은 문제가 국가 사이에 정보를 주고 받을 때 발생
- 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석 할 수 밖에 없음
- 다국어 처리를 위해 표준인 **유니코드**를 만듦
- 유니코드 컨소시엄에서 관리하고 이모지(Emoji)도 유니코드 문자

**유니코드 일부**

![유니코드]()

**유니코드 Character Set**

- 유니코드도 다시 Character Set으로 분류
- UCS-2(Universal Character Set 2)
- UCS-4(Universal Character Set 4)
- 유니코드를 저장하는 변수의 크기를 정의
    - 바이트 순서에 대해서는 표준화 하지 못함
- 파일을 읽을 때 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생
    - 유니코드의 적당한 외부 인코딩이 필요하게 됨

**바이트 단위 저장 순서**

바이트 단위 저장 순서가 정해지지 않은 경우 잘못된 해석 가능성

- 여러 바이트로 이루어진 데이터를 저장하는 방식을 Endian 이라고 함 
- Big-endian은 상위 바이트(MSB, Most Significant Byte)**를 가장 낮은 주소에 저장
- Little-endian은 하위 바이트(LSB, Least Significant Byte)**를 가장 낮은 주소에 저장

**유니코드 인코딩**

- UTF-8(in web)
    - MIN: 8-bit, MAX: 32-bit(1 byte*4)
    - 필요한 크기에 따른 저장 방법 예
        - 0xxxxxxx
        - 110xxxxx 10xxxxxx
        - 1110xxxx 10xxxxxx 10xxxxxx
        - 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

- UTF-16(in windows, java)
    - MIN: 16-bit, MAX: 32-bit(2 byte*2)

- UTF-32(in unix)
    - MIN: 16-bit, MAX: 32-bit(4 byte*1)

**Python 인코딩**

- UTF-8
    - 2.x 버전은 기본 인코딩 방식이 ASCII로 UTF-8 사용시 코드 첫 줄에 다음 문자을 추가해야 함
        - #-*- coding: utf-8 -*-
    - 3.x 버전은 UTF-8 방식이 기본이므로 표시 생략
- 다른 인코딩 방식으로 처리시 첫 줄에 작성하는 항목에 원하는 인코딩 방식을 지정해주면 됨

**코드 체계의 핵심**

**전 세계의 모든 문자를 컴퓨터가 일관되게 표현하고 처리하는 것**

---

### 문자열

String: 문자들이 순서대로 나열된 데이터

> 문자 하나하나를 차례대로 모아 놓은 것으로, 텍스트(문장, 단어, 기호 등)를 표현하거나 처리 할 때 사용

**문자열의 분류**

- Length-Controlled 문자열
    - 문자열의 길이 정보를 함께 저장해서, 그 길이만큼 문자 데이터를 읽는 방식
    - Java, Python, 네트워크 패킷에 사용

- Delimited 문자열
    - 문자열의 끝을 나타내는 특정한 구분자(Delimiter)가 있어서, 구분자가 나올 때까지 문자열로 인식
    - C 언어는 널문자(null, '\0')를 사용

 Length-Controlled

|   5   |  'H'  |  'e'  |  'l'  |  'l'  |  'o'  |

 Delimited

|  'H'  |  'e'  |  'l'  |  'l'  |  'o'  | '\0' |

**파이썬 str 클래스 구조**

- 길이 외에 다른 정보도 저장
    - PyObject_HEAD: 모든 Python 객체가 상속하는 공통 구조
    - Length: 문자열의 길이
    - hash: 문자열의 해시값으로, 딕셔너리 키로 쓸 때 사용
    - interned: 같은 문자열을 관리하는 플래그
    - kind: 문자열 인코딩의 크기
    - data: 문자열이 저장된 실제 메모리 주소를 가리키는 포인터

**C언어에서 문자열**

- 문자열은 문자들의 배열 형태로 구현된 응용 자료형
- 문자배열에 문자열을 저장할 때는 항상 마지막에 끝을 표시하는 널문자('\0') 필요 
    - char ary[]='abc'; // char ary[]={'a', 'b', 'c', '\0'};
- 문자열 처리에 필요한 연산을 함수 형태로 제공
    - strlen(), strcpy(), strcmp()

**Java에서 문자열**

- 문자열 데이터를 저장, 처리해주는 클래스를 제공
- String 클래스
    - string str ='abc'; // tring str = new String("abc")
- 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공
    - +, length(), replace(), split(), substring(), ...

**Python3에서 문자열**

- 텍스트 데이터의 취급방법이 통일되어 있음
    - python2와 달리 바이트 문자열과 Unicode 구분이 없음
    - 유니코드(Unicode) 기반이라 어떤 언어나 기호도 동일한 방식으로 처리 

- 문자열 기호
    - '(홑따옴표), "(쌍따옴표), '''(홑따옴표 3개), """(쌍따옴표 3개)

- 연산
    - + 연결(Concatenation)
        - 문자열 + 문자열: 이어 붙여주는 역할
        - ex. 'ab' + 'c'
    - * 반복
        - 문자열 * 수: 수만큼 문자열 반복
        - 'ab' * 3

- 문자열은 데티어의 순서가 구분되는 시퀀스 자료형으로 분류됨
    - 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음

- 문자열 클래스에서 제공되는 메소드
    - replace(), split(), isaplpha(), find()

- 문자열은 튜플과 같이 요소값을 변경 할 수 없음(immutable)

- 인덱스를 사용할 수 있음

```python

s = 'abc'
print(s[1])

```

- 요소값을 변경할 수 없음

```python

s = 'abc'
s[1] = 'a' # TypeError: 'str' object does not support item assignment 

```

**C, Java, Python3 문자열의 차이**

- C는 아스키 코드로 저장
    - 한글을 출력할 수 있으나 콘솔의 도움을 받아야 함
- Java는 유니코드(UTF-16, 2-Byte)로 저장
- Python3는 유니코드(UTF-8)로 저장

```C

char *name = "홍길동";
int count =strlen(name);
printf("%d", count);

```

```java

String name = "홍길동";
System.out.println(name.length());

```

```python

name ="홍길동"
print(len(name))

```
**Python에서의 문자열 입력**

- input() 함수로 읽기

```python

text = input()
# Hello python을 입력하면 빈칸을 포함해 한 행을 읽어 들임

```

> text = list(input)을 사용하면 각 글자가 리스트의 원소로 저장됨
> ['H', 'e', 'l', 'l', 'o',' ', 'p', 'y', 't', 'h', 'o', 'n']
> 문자열은 수정이 불가하지만 리스트로 들어와 원소 별로 다른 글자로 바꿀 수 있음

---

### 연산

**문자열 뒤집기**

- 문자열을 역순으로 재정의

```python 

s = 'Reverse this strings' # 'sgnirts siht esreveR'
s = s[::-1]

```

- 리스트로 변환 후 다시 문자열로 변환 

```python 

s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)

```

**회문**

- "기러기", "스위스", "토마토"와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
- 문자열 길이의 반만 비교하면 됨

```python 

is_palindrome(txt):
    for i : 1 -> len(txt/2)
        if txt[i] != txt[len(txt) - i]
                return False
    return True

```

**문자열 비교**

- == 연산자와 is 연산자
- ==는 값(value)이 같은지를 비교
- is는 객체의 정체성(identity), 즉 **같은 객체(메모리 주소)** 인지 비교
- == 연산자는 내부적으로 특수 메서드 __eq__()를 호출

```python 

s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2]+'c'

print(s1 == s2) # True
print(s1 is s2) # True
print(s4 == s5) # True
print(s4 is s5) # False

```

```python 

a = [1, 2, 3]
b = [1, 2, 3]

print(a == b) # True (값이 같음)
print(a is b) # False (다른 객체임)

```
**C, Java에서의 문자열 비교**

- C
- strcmp() 함스를 이용해 문자열의 내용을 비교

- Java
- == 연산자는 객체의 주소(참조)를 비교 (Python의 is 연산자 역할)
- equals() 메소드는 객체의 내용을 비교 (Python의 == 역할)

**사전 순서 비교**

- 비교 연산자 < 사용
    - 유니코드를 비교

- 두 문자열의 사전상 순서를 비교하는 my_strcmp() 함수를 구현한 예

```python

def my_strcmp(s1, s2):
    if s1 < s2:
        return -1
    elif s1 > s2:
        return 1
    else:
        return 0
```

> 문자열에 대한 < 연산은 유니코드 값에 대한 비교
> 따라서 'Apple' < 'apple' 도 True이고 'Zebra' < 'apple' 도 True

**문자열 숫자를 숫자로 변환**

- 문자열을 숫자로 변환하는 예

```python 

a = int('123')
b = float('3.14')
c = int('A0', 16)

```

- 숫자를 문자열로 변환하는 예

```python 

a = str(123)
b = str(3.14)

```

---

## 패턴매칭
### 고지식한 패턴 검색

Brute Force: 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식

**구현**

- 본문의 비교위치 i, 패턴에서의 비교위치 j
- 일치하면 i, j 증가, 실패하면 i는 이전 시작위치 다음으로, j는 맨 앞으로 초기화

**코드**

```python

def brute_force(p, t):          # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
    i = 0 
    j = 0
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != p[j]:        # 다른 글자인 경우
            i = i -j
            j = -1
        i = i + 1
        j = j + 1
    if j == M : return i - M    # 검색 성공
    else: return -1             # 검색 실패

```

- 시간복잡도: 최악의 경우 모든 위치에 패턴을 비교해야 하므로 O(MN)

---

### KMP 알고리즘

연구자 Knuth, Morris, Pratt 세 사람의 이름에서 유래

- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
    - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는지를 미리 알고 있게 됨 
    - 조건에 따라, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않을 수 있게 됨
    - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 **전처리**가 필요

- 시간 복잡도 
    - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 O(M)
    - 텍스트의 길이가 N일 때 검색은 최악의 경우 O(N)
    - 결과적으로 O(M+N)
    - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 \theta (N)이 됨

**아이디어**

- 텍스트에 abcdabc까지는 매치되고, e에서 실패한 상황
    - 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용

**LPS(Longest Prefix which is also Suffix)배열**

- 접두사이자 접미사인 문자열의 최대 길이
- 일치하지 않을 때 비교할 인덱스
- 구현에 따라 next, pi 배열로도 불림 

---

### 보이어-무어 알고리즘

Boyer-Moore: 상용 스프트웨어에서 채택하고 있는 알고리즘

- 실제 검색에서 매우 빠른 성능
    - 패턴 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이 만큼 됨

**불일치 문자 휴리스틱(Bad-Character Heuristic)**

- 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
    - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프

**Skip 배열**

![사진]()

**문자열 매칭 알고리즘 비교**
- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
- 고지식한 패턴 검색 알고리즘: 수행시간 O(mn)
- 카프-라빈 알고리즘: \theta (n)
- KMP 알고리즘: \theta (n)
- 보이어-무어 알고리즘
    - 앞의 두 매칭 알고리즘들은 텍스트 문자열의 문자를 적어도 한번씩 흝기때문에 최선의 경우에도 \omega (n)
    - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 됨
    - 패턴의 오른쪽부터 비교
    - 완전한 보이어-무어 알고리즘은 일치 접미부 휴리스틱을 함께 사용
    - 최악의 경우 O(mn)이지만 일반적으로 \theta (n)보다 시간이 덜 듬
    - grep, VS Code, JVM 등에서 사용된다고 알려져 있음

---

### 문자열 암호화

**시저 암호(Caesar cipher)**

- 줄리어스 시저가 사용했다고 하는 암호
- 시저는 기원전 100년경에 로마에서 활약했던 장군
- 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동] 시킴으로써 암호화
- 1 만큼 평행한 암호화의 예

| 평 문  | S | A | V | E |  | P | R | I | V | A | T | E |   | R | Y | A | N |
|  ---- | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| 암호문 | T | B | W | F | A | Q | S | J | W | B| U | F | A | S | Z | B | O |

- 1 만큼 평행했을 때 1을 키 값이라고 함 
-  수신자 이외의 사람(키가 1이라는 사실을 모르는 사람)이 암호문 TBWDAQSJWBUFASZBO을 보고 SAVE PRIVATE RYAN 라는 메세지를 맞출 수는 없는가?

**시저 암호문에 대한 전사공격**

- 모든 키 값을 사용해 해석 시도 
- 대문자만 사용한다는 것은 알고 있음

**문자 변환표를 이용한 암호화(단일 치환 암호화)**

- 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법
- 알파벳 하나를 다른 고정된 알파벳으로 바꾸는 방법

**단일 치환 암호화의 복호화**

- 모든 키의 조합이 필요
- 키의 총 수 
    - 26 x 25 x 24 x 23 x ... x 1 =26! = 403291461126605635584000000
    - 1초에 10억 개의 키를 적용할 수 있어도 120억년 이상 걸림

- 빈도 분석 공격 가능
    - 가장 많이 쓰이는 글자 E, T, A 등 임
    - 암호문에서 자주 나오는 문자를 추정해 대응시키면 해독이 가능

**문자열 압축**
- Run-length encoding 알고리즘
    - 같은 값이 몇 번 반복되는가를 나타내는 방식
    - 이미지 파일 포맷 중 BMP 파일의 압축 방법 중 하나로 사용

- 허프만 코딩 알고리즘
    - 더 효율적이고 일반적인 압축 방법
    - 자주 나오는 문자는 짧은 코드, 드물게 나오는 문자는 긴 이진 코드를 부여해, 결과적으로 전체 데이터의 평균 비트 수를 최소화하는 알고리즘
