# 시간 복잡도(Time Complexity) 

알고리즘이 문제를 해결하는 데 **걸리는 시간**을 입력 크기(보통 n)에 대한 함수로 표현한 것, 주로 최악의 경우(Worst‑Case)를 기준으로 분석하며, 크게 다음 세 가지

---

## 1. 빅오 표기법(Big‑O Notation)

* 알고리즘의 시간 증가율을 상한선으로 나타냄
* 상수․저차항․계수 무시
* 예:

  * O(1): **상수 시간**
  * O(log n): **로그 시간**
  * O(n): **선형 시간**
  * O(n log n): **준선형 시간**
  * O(n²): **이차 시간**
  * O(2ⁿ): **지수 시간**

---

## 2. 주요 시간 복잡도 유형

|     표기     | 이름     | 특징                   | 예시 알고리즘/연산                                       |
| :--------: | :----- | :------------------- | :----------------------------------------------- |
|    O(1)    | 상수 시간  | 입력 크기와 무관하게 일정한 시간   | - 배열 원소 접근 `a[i]`<br/>- 해시맵 조회                   |
|  O(log n)  | 로그 시간  | 입력이 커져도 추가 비용이 작음    | - 이진 검색(Binary Search)                           |
|    O(n)    | 선형 시간  | 입력 크기에 비례해 증가        | - 단일 순회 검색(Linear Search)<br/>- 단순 합계 계산         |
| O(n log n) | 준선형 시간 | 효율적인 정렬 알고리즘 대부분     | - 병합 정렬(Merge Sort)<br/>- 힙 정렬(Heap Sort)        |
|    O(n²)   | 이차 시간  | 입력이 두 배면 실행 시간이 네 배로 | - 버블 정렬(Bubble Sort)<br/>- 선택 정렬(Selection Sort) |
|    O(2ⁿ)   | 지수 시간  | 입력이 조금만 커져도 폭발적으로 증가 | - 피보나치 재귀 계산<br/>- 부분집합 생성(Brute‑Force)          |

---

## 3. 예시

1. **선형 탐색(Linear Search)**

   ```cpp
   // O(n): 배열 a에서 값 x 찾기
   for (int i = 0; i < n; ++i) {
       if (a[i] == x) return i;
   }
   return -1;
   ```

   * 최악의 경우 n번 비교 → O(n)

2. **이진 탐색(Binary Search)**

   ```cpp
   // O(log n): 정렬된 배열 a에서 값 x 찾기
   int lo = 0, hi = n - 1;
   while (lo <= hi) {
       int mid = (lo + hi) / 2;
       if (a[mid] == x) return mid;
       else if (a[mid] < x) lo = mid + 1;
       else hi = mid - 1;
   }
   return -1;
   ```

   * 구간 반으로 줄임 → O(log n)

3. **병합 정렬(Merge Sort)**

   * 분할: 배열을 반으로 → 2번 호출
   * 정복: 합치며 정렬 → O(n)
   * 재귀 관계: T(n) = 2T(n/2) + O(n) → 해석 시 O(n log n)

---

## 4. 평균·최악·최선 경우

* **최악 시간(Worst‑Case)**: 항상 보장되는 성능 분석
* **평균 시간(Average‑Case)**: 일반적 입력 분포 가정 후 계산
* **최선 시간(Best‑Case)**: 가장 유리한 입력 상황

예를 들어, 선형 탐색에서 찾으려는 값이 첫 번째 위치에 있으면 O(1) (Best‑Case), 없으면 O(n) (Worst‑Case)

---

## 5. 왜 중요한가?

* 입력 크기가 커질수록 실행 시간 차이가 극명해짐
* 효율적인 알고리즘 선택으로 **실행 속도** 및 **자원 사용** 최적화 가능
* 코딩 테스트 및 실제 서비스에서 **반응성**, **스케일링** 보장

