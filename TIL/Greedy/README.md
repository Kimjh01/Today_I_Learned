# 탐욕 알고리즘

## 조합적 문제

**부분 집합**

Powerset: 어떤 집합의 공집합가 자기자신을 포함한 모든 부분

> 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 수는 2^n

**집합에 포합된 원소들을 선택하는 것**

부분 집합 예시

- 집합 {A, B, C}로 만들 수 있는 부분 집합의 예시 표
- 부분 집합에는 아무것도 선택하지 않은 경우도 포함 (공집합)

| {A, B, C} |
| --------- |
|    { }    |
|    {A}    |
|    {B}    |
|   {A, B}  |
|    {C}    |
|   {A, C}  |
|   {B, C}  |
| {A, B, C} |

**집합에서 부분 집합을 찾아내는 구현 방법**

1. 완전탐색

- 재귀호출을 이용한 완전탐색으로, 부분 집합을 구할 수 있음
- 실전 보다는 완전 탐색 학습용으로 추천하는 방법

2. Binary Counting

- 2진수 & 비트연산을 이용하여, 부분 집합을 구할 수 있음
- 모든 부분 집합이 필요할 때 사용하는 추천 방법

**완전탐색으로 부분 집합 구하기**

- 민철이 친구는 세명 {min, co, tim}
- 함께 영화관에 갈 수 있는 멤버를 구성하고자 함
- 모든 경우의 수를 출력

**완전 탐색을 이용해 구현**

Branch: 2개
Level: 3개 

```python 

arr = ['O', 'X']
path = []
name = ['MIN', 'CO', 'TIM']

def run(lev):
    if lev == 3:  # 깊이가 3이 되면 출력
        print(path)
        return

    for i in range(2):  # O, X 두 가지 선택
        path.append(arr[i])   # 선택 추가
        run(lev + 1)          # 다음 단계 재귀 호출
        path.pop()            # 백트래킹

run(0)


```

- 결과

['O', 'O', 'O']
['O', 'O', 'X']
['O', 'X', 'O']
['O', 'X', 'X']
['X', 'O', 'O']
['X', 'O', 'X']
['X', 'X', 'O']
['X', 'X', 'X']


- 완성된 소스 코드

```python 

arr = ['O', 'X']
path = []
name = ['MIN', 'CO', 'TIM']

def run(lev):
    # 3개를 뽑았을 때 출력
    if lev == 3:
        print_name()
        return

    for i in range(2):  
        path.append(arr[i])   # 선택 추가
        run(lev + 1)          # 다음 단계 재귀
        path.pop()            # 백트래킹

# 이름 출력 함수
def print_name():
    print('{ ', end='')
    for i in range(3):
        if path[i] == 'O':    # 'O'인 경우만 이름 출력
            print(name[i], end=' ')
    print('}')

run(0)

```
- 결과

{ MIN CO TIM }
{ MIN CO }
{ MIN TIM }
{ MIN }
{ CO TIM }
{ CO }
{ TIM }
{}


**바이너리 카운팅(Binary Counting)**

- 원소 수에 해당하는 N개의 비트열을 이용해 부분집합을 표시
- 001 이면 부분 집합 {A}를 나타냄
- 0번 비트가 1이므로 첫 원소인 A만 포함된 부분집합을 나타냄
- 110 이면 부분 집합 {B, C}를 나타냄
- 1번, 2번 비트가 1이므로, 두번째와 세번째 원소인 B, C가 포함된 부분집합을 나타냄

| 10진수 | 2진수 | 부분집합 {A, B, C} |
| ---- | --- | -------------- |
| 0    | 000 | {}             |
| 1    | 001 | {A}            |
| 2    | 010 | {B}            |
| 3    | 011 | {A, B}         |
| 4    | 100 | {C}            |
| 5    | 101 | {A, C}         |
| 6    | 110 | {B, C}         |
| 7    | 111 | {A, B, C}      |

**부분 집합의 총 개수**

- 만들 수 있는 집합의 총 개수는 2^n이며 n = 3이기에, 총 8개의 부분 집합 존재
- 2^n은 `1 << n` 공식을 이용하여 빠르게 구할 수 있음

**부분 집합 {B, C}를 만드는 과정**

-  6 (0b110)에서 비트 연산을 이용하여 마지막 한자리가 1인지 0인지 검사

```python

arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
    for i in range(n):
        if tar & 0x1:
            print(arr[i], end='')
        tar >>= 1

get_sub(6)

```

**완성된 부분 집합 코드**

- get_sub(0) ~ get_sub(7)까지 호출하여 모든 부분 집합을 출력

```python

arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
    for i in range(n):
        if tar & 0x1:          # 마지막 비트가 1이면 원소 선택
            print(arr[i], end='')
        tar >>= 1              # 비트 오른쪽 이동

for tar in range(1 << n):       # 2^n 개 (0 ~ 7)
    print('{', end='')
    get_sub(tar)
    print('}')

```

- 결과

{}
{A}
{B}
{AB}
{C}
{AC}
{BC}
{ABC}

**친구와 카페 방문**

민철이는친구 {A, B, C, D, E}가 있음

이 중 최소 2명 이상의 친구와 함께 카페에 가려고 함

총 몇가지 경우가 가능할까?

---

## 조합

combination: 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

순열: {A, B, C, D, E} 5명 중 1등, 2등, 3등 뽑기

- A B C와 C B A는 다른 경우임 (즉, 순서를 고려)

$^nP_r = \dfrac{n!}{(n-r)!}, \quad (n \geq r)$

조합: 5명 중 3명 뽑기

- A B c와 C B A는 같은 경우(즉, 순서를 고려하지 않음)

$^nC_r = \dfrac{n!}{(n-r)!\,r!}, \quad (n \geq r)$

**만약 5명 중 3명을 뽑는 코드는 몇 중 for문이 필요할까?**
-> 3중 for문으로 구현 가능

**만약 5명 중 n명을 뽑는 코드는 몇 중 for문이 필요할까?**

-> N중 for문으로 구현이 가능 즉, 재귀호출 구현이 필요
-> Branch: 최대 5개
-> Level: n

**코드에 start 파라미터를 추가하여 조합 소스코드를 완성**

- Level = n
- Branch = 5

1. 처음 recur 함수의 start 값은 0, 따라서 0 ~ 5까지 반복하면서 재귀호출을 함
2. 만약 i가 3이 선택되는 경우는 재귀 호출할 때 start는 4가 됨, 다음 for문은 4부터 수행

```python 

arr = ['A', 'B', 'C', 'D', 'E']
n = 3

path = []

def recur(cnt, start):
    if cnt == n:  # n개를 뽑았을 때 출력
        print(*path)
        return

    for i in range(start, len(arr)):
        path.append(arr[i])          # 현재 원소 선택
        recur(cnt + 1, i + 1)        # 다음 단계 재귀
        path.pop()                   # 백트래킹

recur(0, 0)

```

---

## 팀욕 알고리즘 

Greedy: 결정이 필요할 때, 현재 기준으로 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘

**대표적인 문제 해결 기법**

1. 완전 탐색(Brute-Force)
- 답이 될 수 있는 모든 경우를 시도해보는 알고리즘

2. Greedy 
- 결정이 필요할 때 가장 좋아 보이는 선택지로 결정하는 알고리즘

3. DP
- 현재에서 가장 좋아 보이는 것을 선택하는 것이 아닌, 과거의 데이터를 이용항 현재의 데이터를 만들어내는 문제해결기법

4. 분할 정복
- 큰 문제를 작은 문제로 나누어 해결하는 문제해결기법

**동전 교환 문제**

10원, 50원, 100원, 500원이 있을 때 1,730원을 거슬러주기 위해 사용할 수 있는 최소 동전 수는 몇 개인가?

- 큰 동전부터 최대한 거슬러 주면 됨
- 이처럼, 좋아 보이는 값을 먼저 선택하는 것을 그리디(Greedy), 탐욕(욕심쟁이) 알고리즘이라 함

```python 

coin_list = [500, 100, 50, 10]   # 큰 동전부터 앞으로 작성
target = 1730
cnt = 0

for coin in coin_list:
    possible_cnt = target // coin      # 현재 동전으로 가능한 최대 개수
    cnt += possible_cnt                # 정답(총 동전 개수)에 더한다
    target -= coin * possible_cnt      # 해당 금액만큼 차감한다

print(cnt)

```

**동전 구성이 다른 경우**

5원, 20원, 100원이 있을 때 530원을 거슬러주기 위해 사용할 수 있는 최소 동전 수는 몇 개인가?

**동전 교환 문제를 완전탐색으로 해결한다면?**

1. 0원이 될 때까지 모든 경우를 다 구함
2. 최소 Level이 되는 경우를 찾으면 정답

**동전 교환 문제를 풀 때, Greedy 알고리즘에서의 예외**

만약 100원을 거슬러 주어야 하는 경우, 총 몇 개의 동전이 필요한가?

Greedy로 접근 -> 액수가 큰 동전을 먼저 선택하면 4개 (70원 하나, 10원 3개)
정답 -> 만약 50원 동전만 사용하면 정답은 2개

**Greedy가 성립하는 경우 vs 성립하지 않는 경우**

- 10, 50, 100, 500 처럼 모든 동전이 배수 관계인 경우 Greedy 적용 가능
- 10, 50, 70 처럼 모든 동전이 배수 관계가 아닌 경우는 Greedy 적용 불가

> 그리디 알고리즘은 쉬워 보이나, 예외 없이 모든 경우가 맞는 규칙인지 아닌지 증명이 어려움

**화장실 문제**

기숙사에는 하나의 화장실만 존재
A ~ D 학생은 각자의 평균 화장실 사용 시간이 있음

- A: 15분
- B: 30분
- C: 50분
- D: 10분

만약 A가 먼저 화장실을 이용한다면, 나머지 인원은 대기
B, C, D 각자의 대기시간들의 총 합은 15분 * 3 = 45분

이후, B가 화장실을 이용하는 경우
나저지 인원 C, D는 대기

각자의 대기시간의 누적 합은 45분 + (30분 * 2) = 105분

이후, C가 화장실을 이용하는 경우
나머지 D는 대기

각자의 대기시간의 누적 합은 105분 + 50분 = 155분

마지막으로 D가 화장실을 이용함
이 때는 아무도 기다리지 않기에, 총 대기시간의 누적 합은 155분

---

## Knapsack 문제

0-1 Knapsack (물건을 넣거나 뺄 수만 있는 문제)

도둑이 보물들이 있는 창고에 침입
도둑은 최대 30kg까지 짐을 담아 갈 수 있음

물건의 개수(N) 그리고 물건 별 무게(W)와 가격(P)이 주어질 때,
어떤 물건은 담아야 도둑이 최대 이득을 볼 수 있을지 구하자

|        | 무게 |     값    |
| 물건 1 |  5kg |   50만원  |
| 물건 2 | 10kg |   60만원  |
| 물건 3 | 20kg |  140만원  |

**kg당 가치가 가장 높은 것을 먼저 담으면 안됨**

0-1 Knapsack을 Greedy로 접근하면 안되는 예외 케이스가 존재
0-1 Knapsacka 문제는 greedy로 접근하면 안됨
완전 탐색 혹은 DP로 접근해야 함

|        | 무게 |     값    |   값/kg   |
| 물건 1 |  5kg |   50만원  | 10만원/kg |
| 물건 2 | 10kg |   60만원  |  6만원/kg |
| 물건 3 | 20kg |  140만원  |  7만원/kg |

> kg당 가치가 높은것을 선택하면 안되는 예시. 정답은 물건 2,3을 선택하는 것

0-1 Knapsack과 달리, 물건을 원하는 만큼 자를 수 있는 Knapsack 문제

정답은 아니지만, 가방에 담을 수 있는 예시:
물건1에서 5kg + 물건2에서 10kg + 물건3에서 15kg = 50 + 60 + 105 = 215만원

> Greedy로 접근해도 될지 고민

**Fractional Knapsack 문제 해결 방법**

- Greedy가 성립
- kg 당 가격이 가장 높은 물건을 최대한 담으면 됨

- 최대 수익
    - 가장 kg 당 금액이 높은 물건 1, 전체 사용 (50만원)
        + 두 번째로 kg당 금액이 높은 물건 3, 전체 사용 (140만원)
        + 세 번째로 kg당 금액이 높은 물건 2, 나머지 모두 사용 (5kg만 사용, 30만원)

    = 50 + 140 + 30 = 220만원

```python

n = 3
target = 30   # Knapsack 용량 (KG)
things = [(5, 50), (10, 60), (20, 140)]   # (무게, 가치)

# 정렬: 단위 무게당 가격이 높은 순서
things.sort(key=lambda x: x[1]/x[0], reverse=True)

total = 0
for kg, price in things:
    per_price = price / kg

    # 남은 용량보다 물건이 더 크면 쪼개서 담는다
    if target < kg:
        total += target * per_price
        break

    total += price
    target -= kg

print(int(total))

```

---

## 활동 선택 문제

**회의실 배정**

회의실이 하나인 회사가 있음
여러 팀들이 원하는 회의실 예약 시간이 주어질 때,
가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?

- 희망 회의 개수, 시작 시간, 종료 시간을 입력 받음

**문제 해결 방법**

회의 종료시간이 ㅈ가장 빠른 회의를 먼저 선택
- (2, 4), (4, 6), (7, 8) 또는 (8, 9) 회의를 선택하면 3개의 회의를 배정할 수 있음

**다른 예시 = 활동 선택(Activity-selection problem)문제**

총 10개의 회의 요청이 존재

(5,9), (6,10), (8,11), (1,4), (3,5), (1,6), (5,7), (3,8), (2,13), (12,14)

1) 먼저, 종료 시간을 기준으로 10개의 회의들을 오름차순 정렬

2) 종료 시간이 가장 빠른 회의를 찾자마자, 확정함

3) 확정한 회의의 끝나는 시간을 기준으로 설정

4) 이제 기준 다음으로 가능한 회의 중, 가장 빨리 끝나는 회의를 찾아 확정

5) 2 ~ 4번 반복

**회의실 문제 전략**

1. 끝나는 시간을 기준으로 오름차순 정렬
2. 빠르게 끝나는 회의를 선택하여 확정
3. 이후로 가능한 회의 중, 빠르게 끝나는 회의를 선택하여 확정

**활동 선택 문제(Activity-selection problem)**

- 종료 시간이 빠른 순서로 활동을 정렬
- 첫 번째 활동(A1)을 선택
- 선택한 활동(A1)의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
- 남은 활동들에 대해 앞의 과정을 반복

**알고리즘 설명**-

```python 

모든 활동을 종료 시간 기준으로 오름차순 정렬한다.

선택한 활동 리스트를 비운다.
마지막으로 선택한 활동의 종료 시간 = 0

for 각 활동 i in 정렬된 활동 리스트:
    if s[i] >= 마지막으로 선택한 활동의 종료시간:
        선택한 활동 리스트에 i 추가
        마지막으로 선택한 활동의 종료 시간 = f[i]

```

```python

# 활동의 (시작시간, 종료시간) 리스트
activities = [(1, 4), (3, 5), (0, 6),
              (5, 7), (3, 9), (5, 9),
              (6, 10), (8, 11), (8, 12),
              (2, 14), (12, 16)]

# 1. 종료 시간 기준으로 정렬
activities.sort(key=lambda x: x[1])

selected = []   # 선택된 활동 리스트
last_end = 0    # 마지막으로 선택된 활동의 종료 시간

# 2. 탐색
for s, f in activities:
    if s >= last_end:     # 겹치지 않으면 선택
        selected.append((s, f))
        last_end = f      # 종료 시간 갱신

print("선택된 활동들:", selected)

```

