# SW 문제해결

## SW 문제해결

**SW 문제해결 역량이란?**

프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력

프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있음

문제해결 역량은 추상적인 기술
- 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없음
- 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않음

문제해결 역량을 향상시키기 위해서 훈련이 많이 필요함

**문제해결 과정**
1) 문제를 읽고 이해
2) 문제를 익숙한 용어로 재정의
3) 어떻게 해결할지 계획을 세움
4) 계획을 검증
5) 프로그램으로 구현
6) 어떻게 풀었는지 돌아보고. 개선할 방법이 있는지 찾음

**리스트에 숫자 넣기**
- 수 N을 입력 받음
- 윗 줄에는 N부터 1씩 증가되는 숫자 4개를 왼쪽에 채움
- 아랫 줄에는 N부터 1씩 감소하는 숫자 4개를 오른쪽에 채움
- 최종 결과를 출력, 빈 공간은 0으로 출력

**설계 예시**
- 2 x 7 크기의 0으로 채운 리스트를 준비
- 수 N을 입력 받음
- t1 = N 대입 후, for문을 4번 돌려 t1 값을 리스트에 넣음 range(0,4)
- t2 = N 대입 후, for 문을 4번 돌려 t2 값을 리스트에 넣음 range(6,2,-1)
- 리스트 출력

**SW문제해결 능력을 기르는 이유**
- 코딩을 더 잘하게 하는 능력을 기르기 위함
- SWEA 문제를 통해 기본문법 & 자료구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련

**SWEA 문제를 잘 풀기 위한 전략**
1) 완벽한 문제 이해
2) 종이와 펜을 이용한 설계하기 (어떻게 구현할지 계획하기)
3) 설계 한대로 구현 & 디버깅을 함

**알고리즘이란?**
- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있음

**알고리즘의 효율**
공간적 효율성과 시간적 효율성
- 공간적 효율성은 알고리즘이 필요로 하는 메모리 공간을 말함
- 시간적 효율성은 알고리즘이 작업을 완료하는데 걸리는 시간을 말함
- 효율성을 뒤집어 표현하면 복잡도 (Complexity)가 됨, 복잡도가 높을수록 효율성은 저하됨

- 시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 나타냄

**복잡도의 점근적 표기**
시간(또는 공간)복잡도는 입력 크기에 대한 함수로 표기
- 이 함수는 주로 여러 개의 항을 가지는 다항식
- 이를 단순한 함수로 표현하기 위해 점근적 표기(Asympototic Notation)를 사용

입력크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
- O(Big-Oh) 표기
- Ω(Big-Omega) 표기
- Θ(Big-Theta) 표기

**O(Big-Oh) 표기**
- O - 표기는 복잡도의 점근적 상한을 나타냄 
- 복잡도가 f(n) = 2n^2-7n+4이라면, f(n)의 O-표기는 O(n^2)
- 먼저 f(n)의 단순화된 표현은 n^2
- 단순화된 함수 n^2에 임의의 상수 c를 곱합 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨 (단, c>0)

**자주 사용하는 O-표기**
O(1) 상수시간 (Constant time)
O(logn) 로그(대수)시간 (Logarithmic time)
O(n) 선형 시간 (Linear time)
O(nlogn) 로그 선형 시간 (Log-linear time)
O(n^2) 제곱 시간 (Quadratic time)
O(n^3) 세제곱 시간(Cubic time)

**O(N) 이해하기**
만약 N이 10,000이고 O(N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까? **10,000번**

**만약 O(N^2)라면?**
만약 N이 10,000이고 O(N^2)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까? **100,000,000번**

**만약 O(log N)라면?**
만약 N이 10,000이고 O(log N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까? **약 13.3번**

컴퓨터 분야에서 log의 밑 수는 10이 아니라 2
- 2^13 < 10,000 < 2^14

2의 몇 승이 1억이 되는지 확인해 볼 수 있음
- 2^26 < 100,000,000 < 2^27

**복잡도 비교**
- O(log N)은  O(1) 보다는 느리지만, N이 작은 경우 유사한 성능
- O(Nlog N)은  O(N) 보다는 느리지만, N이 작은 경우 유사한 성능

--- 

## 진법과 연산

**2진수, 8진수, 10진수, 16진수**
- 10진수: 사람이 사용하는 진수, 수 하나를 0 ~ 9로 표현
- 2진수: 컴퓨터가 사용하는 진수, 수 하나를 0 ~ 1로 표현
- 8진수: 2진수를 더 가독성 있게 사용
- 16진수: 2진수를 더 가독성있게 사용, 수 하나를 0~9, A, B, C, D, E, F로 표현

(168)_{10} = (1010 1000)_{2} = (250)_{8} = (A8)_{16}

**왜 16진수를 사용하는 것인가?**
2진수를 사람이 이해하기 편하도록 10진수로 변환 시
- 인간이 이해하기 편하지만, 연산이 오래 걸림

2진수를 사람이 이해하기 편하도록, 16진수로 변환 시
- 인간이 이해하기 어렵지만, 연산 속도가 매우 빠름

**용어**

HEX: 16진수
DEC: 10진수
OCT: 8진수
BIN: 2진수

**암기!**
1) 2진수, 10진수, 16진수를 왜 쓰는지 이해
2) 손으로 변환하는 방법을 익힘
3) 프로그래밍으로 진수 변환을 직접 구현

**진법 변환**

**10 진수 -> 타 진수로 변환**

원하는 타진법의 수로 나눈 두 나머지를 거꾸로 읽음

ex. (149)_{10} = (10010101)_{2} = (225)_{8} = (95)_{16}

**수기로 10진수 -> 2 진수로 변환 해보기**
- 10진수를 지속적으로 2로 나누어 구현
- 마지막으로 List를 거꾸로 뒤집기

```python 

tar = 149
result = []

while tar != 0:
    result.append(tar%2)
    tar //= 2

result.reverse()
print(result)

```

**16진수와 2진수 변환**

- 2진수, 10진수간 변환은 연산이 많으나, 2진수, 16진수간 변환은 연산이 없음
- 진법 변환을 빠르게 할 수 있으려면 진수 표를 암기하는 것을 권장

|  2진수  |  10진수  |  16진수  |
| ------ | -------- | -------- |
|  0000  |    0    |     0     |
|  0001  |    1    |     1     |
|  0010  |    2    |     2     |
|  0011  |    3    |     3     |
|  0100  |    4    |     4     |
|  0101  |    5    |     5     |
|  0110  |    6    |     6     |
|  0111  |    7    |     7     |
|  1000  |    8    |     8     |
|  1001  |    9    |     9     |
|  1010  |   10    |     a     |
|  1011  |   11    |     b     |
|  1100  |   12    |     c     |
|  1101  |   13    |     d     |
|  1110  |   14    |     e     |
|  1111  |   15    |     f     |

**7비트 이진수를 10진수로 변환하여 출력하기**

0/1로 이루어진 1차 배열(문자열)을 **7비트씩 묶어** 각각을 **10진수**로 변환해 출력
(예: `0000001` → 1, `0001101` → 13)

* 입력:
  `0000000111110000001100000011100011000011110011111001111100111`
  
* 출력:
  `0 120 12 7 76 24 60 121 124 103`

```python

def chunks_of_7(bitstring: str):
    # bitstring을 7비트 단위로 자르는 제너레이터
    for i in range(0, len(bitstring), 7):
        yield bitstring[i:i+7]

def decode_7bit_binary(bitstring: str):
    # 7비트 이진 문자열을 10진수 리스트로 변환
    result = []
    for bits in chunks_of_7(bitstring.strip()):
        if len(bits) < 7:           # 남은 비트가 7 미만이면 무시(필요 시 0패딩 가능)
            break
        result.append(int(bits, 2)) # 2진수 → 10진수
    return result

# 사용 예시
s = "0000000111110000001100000011100011000011110011111001111100111"
print(*decode_7bit_binary(s))  # 공백으로 구분하여 출력

```

> 남은 비트가 7의 배수가 아닐 때는 기본적으로 **버린다**. 필요하다면 `bits.ljust(7, '0')`로 **0 패딩**하여 처리

---

## 비트 연산

**비트와 바이트**

* 1 bit은 0과 1을 표현하는 정보의 단위
* 1 Byte는 8 bit를 묶어 1 Byte라고 함 (메모리 주소가 부여되는 단위)

**예시**
`1001011011011100` 은 총 16비트이며, 2바이트임

**비트 연산**

* 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함
* 비트 연산은 사람이 사용하는 사칙연산이 아닌 컴퓨터가 사용하는 연산
* 프로그래밍에서 비트연산을 활용한 코딩 방법을 익히는 것이 목적



**AND와 OR 비트 연산자**

* `a AND b` : a, b 둘 다 1일 때만 결과가 1, 그 외에는 0
* `a OR b` : a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0

| 연산자 | 기능                             |                       |         |
| --- | ------------------------------ | --------------------- | ------- |
| `&` | 비트단위 AND 연산을 함 (`num1 & num2`) |                       |         |
| \`  | \`                             | 비트단위 OR 연산을 함 (\`num1 | num2\`) |

**파이썬 구현 (AND, OR)**

7 & 5를 2진수로 표현하면 `0b111 & 0b101`

```python
print(7 & 5)  # 5
print(7 | 5)  # 7
```

**2진수, 16진수, 10진수 변환**

* 2진수는 `0b`를 접두사로 붙여 표현
* 16진수는 `0x`를 접두사로 붙여 표현

```python
print(bin(10))   # 0b1010
print(hex(10))   # 0xa

print(int('1011', 2))  # 11 (2진수 → 10진수)
print(int('b', 16))    # 11 (16진수 → 10진수)
```

---

## XOR와 NOT 연산자

* `^` : XOR 연산자, 두 비트가 다르면 1, 같으면 0

| 연산자 | 기능                             |
| --- | ------------------------------ |
| `^` | 비트단위 XOR 연산을 함 (`num1 ^ num2`) |

```python
a = bin(0b1011 ^ 0b1101)
print(a)  # 0b110
```

**신기한 XOR**

* 특정 수로 두 번 XOR을 하면 원래 값으로 돌아옴

예시

```
7070 ^ 1004 = 6258
6258 ^ 1004 = 7070
```

**[도전] 암호화 프로그램 제작**

* 수를 입력받고, 암호화를 해주거나(인코딩), 암호를 해제해주는(디코딩) 프로그램 제작
* KEY 값은 1004로 정함

예시

* 입력: `E 1000` → 출력: 1000을 인코딩한 값
* 입력: `D 4` → 출력: 4를 디코딩한 값


**비트 연산자 (Shift)**

* `<<` : Left Shift, 비트를 왼쪽으로 밀어냄
* `>>` : Right Shift, 비트를 오른쪽으로 밀어냄

| 연산자  | 기능            |
| ---- | ------------- |
| `<<` | 비트를 왼쪽으로 이동함  |
| `>>` | 비트를 오른쪽으로 이동함 |

```python
print(bin(0b1101 << 2))  # 0b110100
print(bin(0b1101 >> 2))  # 0b11
```

**[도전] Left Shift(<<)를 이용한 프로그래밍**

반복문을 이용하여 아래와 같이 출력

출력 결과

```
0b1 1
0b10 2
0b100 4
0b1000 8
0b10000 16
```

**비트 연산 응용 1**

* `1 << n` 은 $2^n$ 의 값을 가짐
* 임베디드 분야에서 계산을 빠르게 하기 위해 사용됨

---

**비트 연산 응용 2**

* `i & (1 << n)` 은 i의 n번째 비트가 1인지 확인할 수 있음
* 예시: `1101 & (1 << 2)` → 결과값이 0100이므로 2번째 비트가 1임

---

**음수 표현 방법**

* 컴퓨터는 음수를 **2의 보수**로 관리
* 맨 앞자리 비트(MSB)는 부호 비트로 사용
* 2의 보수를 사용하는 이유는 연산 속도를 올리고 +0, -0을 따로 취급하지 않기 위함

```python
def bit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output)

for i in range(-5, 6):
    print(f"{i} = ", end='')
    bit_print(i)
```

출력 예시

```
-5 = 11111011
-4 = 11111100
...
0  = 00000000
1  = 00000001
...
5  = 00000101
```

---

**2의 보수 예시**

* `10001` 의 2의 보수 → 뒤집고 +1 → `01110 + 1 = 01111`
* `1111000` 의 2의 보수 → 뒤집고 +1 → `0000111 + 1 = 0001000`

---

**신기한 2의 보수**

* 2의 보수를 두 번 취하면 원래 값으로 돌아옴
* `10001` → 2의 보수 `01111`
* `01111` → 다시 2의 보수 `10001`

---

**-5를 2의 보수로 표현하는 방법 (8bit 가정)**

* 5를 2진수로 나타내면 `00000101`
* 음수이므로 MSB = 1
* 나머지 7bit 뒤집고 +1
* `1111010 + 1 = 1111011`
* 따라서 `-5 = 11111011`

---

**bitwise NOT 연산자**

* `~` 연산자는 모든 비트를 반전시킴
* 예: 8bit에서 `~(00011111)` 은 `11100000` 

---

**파이썬에서 NOT 연산자 실행**

* 파이썬에서 `~4` 를 실행하면 `-5` 가 출력

과정

* 4는 `0b0100` (양수)
* NOT 적용 → `1011`
* MSB=1 이므로 음수, 나머지 비트 `011`
* 2의 보수 취하면 `100 + 1 = 101` → 5
* 따라서 `-5` 로 표현됨

```python
print(~4)  # -5
```

---

**[도전] 비트연산 문제 (SWEA 10726 이진수 표현)**

* 정수 N, M이 주어질 때, M의 이진수 표현의 마지막 N비트가 모두 1인지 확인
* 모두 1이면 ON, 아니면 OFF 출력

예시

```
N=5, M=31
31 = 00011111
5개 비트가 모두 1이므로 → ON
```

---

## 실수 

* 파이썬은 f-string 문법을 지원

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다')
print(f'변수 값은 {t2} 입니다')
```

출력

```
변수 값은 10 입니다
변수 값은 3.141592 입니다
```

**소수점 출력 방법**

* `{변수:.2f}` : 소수점 둘째 자리까지 출력, 셋째 자리에서 반올림

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다')
print(f'변수 값은 {t2:.2f} 입니다')
```

출력

```
변수 값은 10 입니다
변수 값은 3.14 입니다
```

**파이썬의 실수 표현 범위**

* 파이썬은 64비트 부동소수점으로 실수를 표현
* 약 15~17자리 정밀도와 ±1.8e308 범위를 가짐
* 최대로 표현할 수 있는 값은 약 1.8 × 10^308이며 이 이상은 `inf`로 표현됨
* 최소로 표현할 수 있는 값은 약 5.0 × 10^-324이며 이 이하는 0으로 표현됨

**컴퓨터에서 실수 관리 방식**

* 실수는 정확한 값이 아니라 근사 값으로 저장됨
* 이 때문에 작은 오차가 발생하고 계산 과정에서 다른 결과를 가질 수 있음

```python
print(0.1 + 0.1 + 0.1 == 0.3)  # False
```

**[도전] 실수 값 출력해보기**

* 0.1이 실제로 어떤 값으로 저장되는지 f-string을 이용하여 소수점 20자리 이상 출력

```python
t = 0.1
print(f'{t:.20f}')
```

출력

```
0.10000000000000000555
```

**소수점이 있는 10진수를 2진수로 변환 예시**

* 0.75 = 2^-1 + 2^-2 = 0.11(2)
* 0.40625 = 2^-2 + 2^-3 + 2^-5 = 0.01101(2)

**소수점을 포함한 2진수를 10진수로 변환 예시**

* 예: `1001.0011(2)`

| 항목       | 값      |
| -------- | ------ |
| 1 × 2^3  | 8      |
| 0 × 2^2  | 0      |
| 0 × 2^1  | 0      |
| 1 × 2^0  | 1      |
| 0 × 2^-1 | 0      |
| 0 × 2^-2 | 0      |
| 1 × 2^-3 | 0.125  |
| 1 × 2^-4 | 0.0625 |

총합 = 9.1875

**실수의 표현 (IEEE 754 표준)**

* 컴퓨터는 부동소수점(floating-point) 표기법을 사용
* IEEE 754 표준은 부동소수점 국제표준임
* 소수점의 위치를 고정시켜 지수승과 가수로 표현

예시: `1001.0011` → `1.0010011 × 2^3`

**실수를 저장하기 위한 형식 (IEEE 754, 32비트)**

* 32비트 구조

  * 부호 비트 1bit: 0이면 양수, 1이면 음수
  * 지수부 8bit: 부동소수점의 크기 + bias
  * 가수부 23bit: 실제 값

**12.375를 부동소수점으로 표기**

* 12.375 → 2진수 변환 = `1100.011`
* 정규화: `1.100011 × 2^3`
* 지수부 = 3 + bias(127) = 130 → `10000010`
* 가수부 = `10001100000000000000000`

따라서 IEEE 754 표기

* 부호: 0 (양수)
* 지수: 10000010
* 가수: 10001100000000000000000

**컴퓨터는 실수를 근사적으로 표현**

* 이진법으로 정확히 표현할 수 없는 실수는 근사 값으로 저장됨
* 이로 인해 작은 오차가 발생하고 계산 결과가 다르게 나올 수 있음

**실수 자료형의 유효 자릿수**

* 32비트 실수형: 10진수 약 6자리까지 정확 (C/C++, Java)
* 64비트 실수형: 10진수 약 15자리까지 정확 (C/C++, Java, Python)

**16진수 문자열을 2진수로 변환하여 7bit씩 묶기**

* 입력된 16진수 문자열을 2진수로 변환한 후 앞에서부터 7bit씩 묶어 10진수로 출력

예시

* 입력: `0F97A3`
* 변환: `000011111001011110100011`
* 7bit 묶음: `0000111 1100101 1110100 011`
* 출력 결과: `7 101 116 3`

**예제**

* 입력: `01D06079861D79F99F`
* 출력: `14 65 64 121 67 7 47 31 76 31`

**16진수 문자열에서 암호 비트패턴 찾기**

* 16진수를 2진수로 변환한 후, 암호 패턴 표에 맞춰 연속된 비트열을 찾아야 함
* 암호 패턴은 왼쪽부터 순차적으로 탐색

예시

* 입력: `0DEC`
* 변환: `0000110111101100`
* 암호 패턴: `0000110111101100` → 02

**암호 비트패턴 표 (예시)**

| 숫자 | 비트패턴   |
| -- | ------ |
| 0  | 001101 |
| 1  | 010011 |
| 2  | 111011 |
| 3  | 110001 |
| 4  | 100011 |
| 5  | 110111 |
| 6  | 001011 |
| 7  | 111101 |
| 8  | 011001 |
| 9  | 101111 |

즉, 정리하면

* **16진수 입력 → 2진수 변환 → 7bit 또는 암호패턴 단위로 해석 → 10진수 변환 후 출력** 흐름임

