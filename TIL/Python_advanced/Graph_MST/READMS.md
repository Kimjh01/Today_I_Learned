# Minimum Spanning Tree

# 최소 신장 트리 (MST, Minimum Spanning Tree)

**그래프에서 최소 비용 문제**

* 모든 정점을 연결하는 간선들의 가중치 합이 최소가 되는 트리를 찾는다.
* 두 정점 사이의 비용이 최소인 경로를 찾는다.

**신장 트리**

* N개의 정점으로 이루어진 무방향 그래프에서 N개의 정점과 N-1개의 간선으로 이루어진 트리.

**최소 신장 트리 (MST)**

* 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치 합이 최소인 트리.

```
    (예시 그래프)
    0---32---1
    | \      |
   31  60    21
    |    \   |
    2---46---4---51---6
    |   /    |
   25 34     40
    |/       |
    6---18---5
```

---

# 그래프의 표현

**인접행렬**

```
   0   1   2   3   4   5   6
0   -  32  31   -   -  60  51
1  32   -  21   -   -   -   -
2  31  21   -  46  46   -  25
3   -   -  46   -  34  18   -
4   -   -  46  34   -  40  51
5  60   -   -  18  40   -   -
6  51   -  25   -  51   -   -
```

**인접리스트**

```
0 -> (1,32) -> (2,31) -> (5,60) -> (6,51)
1 -> (0,32) -> (2,21)
2 -> (0,31) -> (1,21) -> (4,46) -> (6,25)
3 -> (4,34) -> (5,18)
4 -> (2,46) -> (3,34) -> (5,40) -> (6,51)
5 -> (0,60) -> (3,18) -> (4,40)
6 -> (0,51) -> (2,25) -> (4,51)
```

# MST 표현

* **그래프 (그림1)**
* **간선들의 배열 (그림4)**
* **인접 리스트 (그림5)**
* **트리 (그림6)**
* **부모-자식 관계 및 가중치 배열 (그림6)**

```
st:   0  2  0  4  2  3  2
val:  0 21 31 34 46 18 25
```

---

# MST 찾기 방법

* **Prim 알고리즘**
* **Kruskal 알고리즘**

# Prim 알고리즘

**정의**
하나의 정점에서 연결된 간선들 중 하나씩 선택하면서 MST를 만들어가는 방식.

1. 임의의 정점을 하나 선택해서 시작
2. 선택한 정점과 인접한 정점들 중 최소 비용의 간선이 존재하는 정점을 선택
3. 모든 정점이 선택될 때까지 반복

**두 집합 유지**

* 트리 정점들 (tree vertices) → MST에 포함된 정점들
* 비트리 정점들 (nontree vertices) → 아직 선택되지 않은 정점들

**의사코드**

```
MST_PRIM(G, r)
  FOR u in G.V
    u.key ← ∞
    u.π   ← NULL
  r.key ← 0
  Q ← G.V

  WHILE Q ≠ ∅
    u ← Extract_MIN(Q)
    FOR v in G.Adj[u]
      IF v ∈ Q AND w(u,v) < v.key
        v.π ← u
        v.key ← w(u,v)
```

# Prim 알고리즘 적용 예

**1단계**

```
간선 후보: 0-1, 0-2, 0-5, 0-6
선택된 정점: {0}
```

**2단계**

```
간선 후보: 0-5, 0-6, 1-2
선택된 정점: {0,2}
```

**3단계**

```
간선 후보: 0-5, 0-6, 1-2, 2-4, 2-6
선택된 정점: {0,2,1}
```

**7단계**

```
최종 MST 간선들: 0-5, 1-2, 2-6, 2-4, 4-3, 3-5
```

# Kruskal 알고리즘

**정의**
간선을 하나씩 선택해 MST를 찾는 알고리즘.

1. 모든 간선을 **가중치에 따라 오름차순 정렬**
2. 가중치가 가장 낮은 간선부터 선택하여 트리에 추가

   * 단, **사이클이 생기면 제외**
3. n-1개의 간선이 선택될 때까지 반복

**예시 간선 정렬**

```
5-3 (18)
1-2 (21)
2-6 (25)
0-2 (31)
0-1 (32)
3-4 (34)
5-4 (40)
2-4 (46)
0-6 (51)
4-6 (51)
0-5 (60)
```

**진행 과정**

* 5-3 선택
* 1-2 선택
* 2-6 선택
* 0-2 선택
* 3-4 선택
* 4-5 선택
  (사이클이 없는 간선들만 채택)

# Kruskal 알고리즘

**정의**
간선을 하나씩 선택하여 MST를 구성하는 알고리즘.

**과정**

1. 모든 간선을 **가중치에 따라 오름차순 정렬**
2. 가중치가 가장 낮은 간선부터 차례대로 선택

   * 단, **사이클이 생기면 제외**
3. n-1개의 간선이 선택될 때까지 반복

**의사코드**

```
MST-KRUSKAL(G, w)
  A ← ∅                     // 공집합
  FOR vertex v in G.V       // 모든 정점에 대해 집합 초기화
    Make_Set(v)

  간선들을 가중치 w에 의해 정렬

  FOR (u, v) ∈ G.E (오름차순)
    IF Find_Set(u) ≠ Find_Set(v)
      A ← A ∪ {(u, v)}
      Union(u, v)

  RETURN A
```

**진행 예시**

* 5-3 (18) 선택
* 1-2 (21) 선택
* 2-6 (25) 선택
* 0-2 (31) 선택
* 3-4 (34) 선택
* 5-4 (40)은 사이클 → 제외
* 2-4 (46) 선택
* 간선 개수 = N-1 = 6개 완성

# 최단 경로 (Shortest Path)

**정의**
간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중, 간선의 가중치 합이 최소인 경로.

**종류**

1. **단일 시작 정점에서 최단 경로**

   * **Dijkstra 알고리즘**: 음의 가중치 허용 X
   * **Bellman-Ford 알고리즘**: 음의 가중치 허용 O
2. **모든 정점 쌍 간 최단 경로**

   * **Floyd-Warshall 알고리즘**

# Dijkstra 알고리즘

**정의**
시작 정점에서 거리가 최소인 정점을 반복적으로 선택해 나가면서 최단 경로를 찾는 탐욕적(greedy) 알고리즘.

**원리**

* 시작 정점 s에서 목표 정점 t까지 가는 최단 경로는
  `s → x`의 최단 경로 + `x → t`의 최단 경로로 구성됨.
* 탐욕 기법을 사용하며, **Prim 알고리즘**과 유사.

**의사코드**

```
Dijkstra(s, A, D)
  U = {s}
  FOR 모든 정점 v
    D[v] ← A[s][v]      // 시작점에서 v까지 거리 초기화

  WHILE U ≠ V
    w ← V-U 중 D[w]가 최소인 정점
    U ← U ∪ {w}
    FOR w에 인접한 모든 정점 v
      D[v] ← min(D[v], D[w] + A[w][v])
```

---

# Dijkstra 알고리즘 적용 예

**예시 그래프**

```
   a --2--> b --7--> d --1--> f
    \       |1       ^
     4      v        |
      \-->  c --3--> e --5--> f
              \------2------^
```

**인접 행렬**

```
    a   b   c   d   e   f
a   0   2   4   ∞   ∞   ∞
b   ∞   0   1   7   ∞   ∞
c   ∞   ∞   0   ∞   3   ∞
d   ∞   ∞   ∞   0   2   1
e   ∞   ∞   ∞   ∞   0   5
f   ∞   ∞   ∞   ∞   ∞   0
```

**초기화**

```
D = {a:0, b:2, c:4, d:∞, e:∞, f:∞}
U = {a}
```

**진행**

1. a에서 b(2), c(4) 업데이트
2. b 선택 → c=3, d=9
3. c 선택 → e=6
4. e 선택 → f=11
5. d 선택 → f=10 (갱신)
6. f 선택 → 종료

**최종 결과**

```
최단 거리
a→b = 2
a→c = 3
a→e = 6
a→d = 9
a→f = 10
```

# Dijkstra 알고리즘 적용 과정

**그래프**

```
   a --2--> b --7--> d --1--> f
    \       |1       ^
     4      v        |
      \-->  c --3--> e --5--> f
              \------2------^
```

---

## 초기화

```
D = {a:0, b:2, c:4, d:∞, e:∞, f:∞}
U = {a}
```

---

## 1단계 (b 선택)

* D\[b] = 2 → 확정
* b에서 인접 정점 갱신

  * c = min(4, 2+1) = 3
  * d = min(∞, 2+7) = 9

```
D = {a:0, b:2, c:3, d:9, e:∞, f:∞}
U = {a, b}
```

---

## 2단계 (c 선택)

* D\[c] = 3 → 확정
* c에서 인접 정점 갱신

  * e = min(∞, 3+3) = 6

```
D = {a:0, b:2, c:3, d:9, e:6, f:∞}
U = {a, b, c}
```

---

## 3단계 (e 선택)

* D\[e] = 6 → 확정
* e에서 인접 정점 갱신

  * f = min(∞, 6+5) = 11

```
D = {a:0, b:2, c:3, d:9, e:6, f:11}
U = {a, b, c, e}
```

---

## 4단계 (d 선택)

* D\[d] = 9 → 확정
* d에서 인접 정점 갱신

  * f = min(11, 9+1) = 10 (갱신됨)

```
D = {a:0, b:2, c:3, d:9, e:6, f:10}
U = {a, b, c, e, d}
```

---

## 5단계 (f 선택)

* D\[f] = 10 → 확정
* 더 이상 갱신 없음

```
D = {a:0, b:2, c:3, d:9, e:6, f:10}
U = {a, b, c, e, d, f}
```

---

# 최종 결과

* a → b = 2
* a → c = 3
* a → e = 6
* a → d = 9
* a → f = 10

즉, **정점 a에서 각 정점까지의 최단 거리**

```
D = {a:0, b:2, c:3, d:9, e:6, f:10}
```
