# Graph

## Graph Basic

아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현

> 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이 

**그래프**

정점(Vertex)들의 집합과 이들을 연결하는 간선 (Edge)들의 집합으로 구성된 자료 구조
| V |: 정점의 개수, | E |: 그래프에 포함된 가선의 개수라 할 때,
| V | 개의 정점을 가지는 그래프는 최대 | E | : | V | * (| V | - 1)/ 2개의 간선을 가질 수 있음

ex. 5개 정점이 있는 그래프의 최대 간선 수는 10(= 5*4/2)개

**그래프 유형**

- 무향(무방향) 그래프 (Undirected Graph)
- 유향(방향) 그래프 (Directed Graph)
- 가중치 그래프 (Weighted Graph)
- 사이클이 없는 방향 그래프 (DAG, Directed Acyclic Graph)

> 무향 그래프

```bash
0 ----- 1 ----- 2
 \     /        |
   \  /         |
     3 ----------
```

> 유향 그래프

```bash
0 ---> 1 ---> 2
^     /        |
 \   v         v
   <-3 <-------
```

> 가중치 그래프

```bash
   (7)       (4)
0 -----> 1 ------> 2
 \       ^\ 
 (3)   (1) \  
   \        v
     ------> 3
         (6)
```

> 사이클 있는 방향 그래프

```bash
0 -> 2 -> 5 -> 7
|         ^ 
v         |
1 -> 3 -> 6
 \________/
```

> 트리 구조 (사이클 없는 무향)

```bash
      0
      |
      1
   /     \
  2       3
 / \       \
5   6       7
```

> 또다른 무향 그래프

```bash
0 - 1 - 2 - 5
    |    \
    3     6
     \
      7
```

**그래프 유형**

완전 그래프: 정점들에 대해 가능한 모든 간선들을 가진 그래프
부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프 

**인접 정점**

인접(Adjacency)

- 두 개의 정점에 간선이 존재(연결됨)하면 서로 인법해 있다고 함
- 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있음

**그래프 경로**

```bash
0 --> 2 --> 4 --> 6
 \           ^ 
  \         /
   > 1 --> 6
      \ 
       > 3 --> 5
        ^     |
         \____|
```

경로란 간선들을 순서대로 나열한 것

    - 간선들: (0, 2), (2, 4) (4, 6)
    - 정점들: 0 - 2 - 4 - 6

경로 중 한 정점을 최대한 한번만 지나는 경로를 **단순경로**라고 함

    - 0 - 2 - 4 - 6, 0 - 1 - 6

시작한 정점에서 끝나는 경로를 **사이클(Cycle)**이라고 함

**그래프 표현**

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬(Adjacent matrix)
    - |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장

- 인접 리스트(Adjacent list)
    - 각 정점마다 해당 정점과 인접 정점 정보를 저장

- 간선의 배열
    - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

**인접 행령: 두 정점을 연결하는 간선의 유무를 행렬로 표현**

```bash
   2
   |
1--0--6
  /   |
 /    |
5-----4
 \   /
   3

```
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|---|
| **0** | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| **1** | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| **2** | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| **3** | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
| **4** | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
| **5** | 1 | 0 | 0 | 1 | 1 | 0 | 0 |
| **6** | 1 | 0 | 0 | 0 | 1 | 0 | 0 |


- |V| x |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
- 무향 그래프 
    - i 번째 행의 합 = i 번째 열의 합 = $V_{i}$의 차수 

- 유향 그래프
    - 행 i의 합 = $V_{i}$의 진출 차수
    - 열 i의 합 = $V_{i}$의 진입 차수 

**인접 리스트**

- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장

```bash

0 -> 6 -> 5 -> 1 -> 2
1 -> 5 -> 4
2 -> 0
3 -> 4
4
5 -> 3 -> 0 -> 4
6

```
- 무향 그래프의 인접 리스트 

무방향 그래프 노드 수 = 간선의 수 * 2
각 정점의 노드 수 = 정점의 차수 

- 유향 그래프의 인접 리스트

방향 그래프 노드 수 = 간선의 수
각 정점의 노드 수 = 정점의 진출 차수 

--- 

## DFS

**DFS(Depth First Search, 깊이 우선 탐색) 알고리즘 - 재귀**

모든 정점을 중복없이 빠집없이 방문하는 경우

- G: 탐색할 그래프
- V: 방문하는 정점

```bash

DFS_Recursive(G, v)
    visited[v] <- True # V 방문 설정

    For each all w in adjacency(G, V)
        IF visited[w] != True
            DFS_Recursive(G, w)

```

**DFS 알고리즘 - 반복**

```bash

STACK s # 스택 생성
visited[] # 방문한 정점 표시
DFS(v)
    push(s, v)
    WHILE NOT isEmpty(s)
        V <- pop(s)
        IF NOT visited[v]
            visited(v)
            For each w in adjacency(V)
                IF NOT visited[w]
        push(s, v)

```

**중복검사가 필요없는 DFS**

- 스택에 push된 정점을 visited에 표시함

```bash

STACK s 
visited[] 
DFS(v)
    push(s, v)
    visited[v]  = True
    WHILE NOT isEmpty(s)
        V <- pop(s)
        visited(v)
        For each w in adjacency(V)
            IF NOT visited[w]
            push(s, v)
            visited[v]  = True

```

---

## BFS

**의사코드 (Pseudocode)**

```markdown
BFS(G, v)  // 그래프 G, 탐색 시작점 v

큐 생성
시작점 v를 큐에 삽입
점 v를 방문한 것으로 표시

WHILE 큐가 비어있지 않은 경우
    t ← 큐의 첫번째 원소 반환
    FOR t와 연결된 모든 선에 대해
        u ← t의 이웃점
        IF u가 방문되지 않은 곳이면
            u를 큐에 넣고, 방문한 것으로 표시
```

---

**BFS 예시 (탐색 순서: ①~⑨)**

```bash
           A (①)
         /  |  \
     B(②)  C(③)  D(④)
     / \        / | \
  E(⑤) F(⑥)  G(⑦) H(⑧) I(⑨)
```

> BFS는 같은 레벨의 노드를 먼저 모두 방문
> 그 다음 레벨의 노드를 순서대로 방문

---

## Union-Find(Disjoint set)

**서로 소 집합(Disjoint set)**

서로 공통 원소가 없는 집합
- 교집합이 없는 집합

대표자(representative)
- 각 집합을 대표하는 하나의 원소를 말함

상호 배타 집합
- 확률, 논리, 집합론에서 동시에 일어날 수 없는 경우, 공통이 없는 경우를 말함
- 집합론에서는 **서로 소와 같은 뜻**으로 사용

표현 방법
- 연결리스트로 표현할 수 있음
- 트리를 이용해 표현할 수 있음

**서로 소 집합 연산**

Make-Set(x)
- x를 원소로 가진 집합을 만듬 

Find-Set(x)
- x가 속한 집합의 대표 원소를 반환 

Union-Set(x)
- y가 속한 집합과 x가 속한 집합의 합집합을 만듬
- x가 합집합의 대표원소가 됨

**상호배타 집합의 예**

Make-Set(x)
Make-Set(y)
Make-Set(a)
Make-Set(b)

Union(x, y)
Union(a, b)

Find-Set(y) -> x
Find-Set(b) -> a

```bash

Union(x, a)

초기 상태 (Make-Set)
x    y    a    b

Union(x, y)
[x  y]    a    b

Union(a, b)
[x  y]   [a  b]

Union(x, a)
[x  y  a  b]

```

**상호 배타 집합 표현 - 연결리스트**

- 같은 집합의 원소들은 하나의 연결리스트로 관리
- 연결리스트의 맨 앞의 원소가 집합의 대표 원소 
- 각 원소는 집합의 대표원소를 가리키는 링크를 가짐


**연결리스트 연산 예**

```markdown
Find-Set(e)  -> a
Find-Set(f)  -> b
Union(a, b)
```

```bash
초기 상태

[a] -> d -> e         [b] -> f         [c]
 ^          ^          ^     ^          ^
rep        tail       rep   tail       rep
                                       tail


Union(a, b) 수행 후

[a] -> d -> e -> b -> f       [c]
 ^                    ^        ^
rep                  tail     rep
                              tail
```

> 각 집합은 `rep(대표원소)`와 `tail(마지막 원소)` 포인터를 관리하며,
> `Union` 시 두 리스트를 연결하고 모든 원소의 대표를 갱신합니다.

**상호 배타 집합 표현 - 트리**

- 하나의 집합(a disjoint set)을 하나의 트리로 표현함
- 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 됨

```bash

  [a]     [b]       [c]
  / \       \
 d   e       f

```
**트리 연산 예**


```markdown
Make-Set(x)  // 집합 생성
p[x] ← x

Find-Set(x)  // 대표 찾기 (재귀)
IF x == p[x] : RETURN x
ELSE         : RETURN Find-Set(p[x])

Find-Set(x)  // 대표 찾기 (반복)
while x != p[x]:
    x = p[x]
return x

Union(x, y)  // 두 집합 합치기
p[Find-Set(y)] ← Find-Set(x)
```

---

- 초기 상태 (Make-Set(a) ~ Make-Set(f))

```bash
[a]   [b]    [c]    [d]    [e]    [f]
```

---

**Union 연산**

```bash
Union(c,d), Union(e,f)

[a]   [b]   [c]   [e]
        ↖ d        ↖ f

Union(d,f)

a    b      c
        ↖ d  ↖ e
               ↖ f
```

**상호배타 집합을 표현한 트리의 배열을 이용한 저장**

| Index | 0 | 1 | 2 | 3 | 4 | 5 |
| ----- | - | - | - | - | - | - |
| 정점    | a | b | c | d | e | f |
| 부모    | 0 | 1 | 2 | 2 | 2 | 4 |

**트리 형태 예시**

```bash
초기 상태: Make_Set(a)~Make_Set(h)
a   b   c   d   e   f   g   h

Union(c,d), Union(e,f), Union(d,f)
a   b        c
        ↖ d  ↖ e
               ↖ f
                   ↖ g
                       ↖ h
```

**부모/랭크 테이블 예시**

| Index | 0 | 1 | 2 | 3 | 4 | 5 |
| ----- | - | - | - | - | - | - |
| 정점    | a | b | c | d | e | f |
| 부모    | 0 | 1 | 2 | 2 | 2 | 4 |
| 랭크    | 0 | 0 | 2 | 0 | 1 | 0 |


**랭크 기반 Union**

* 두 집합을 합칠 때 **랭크(트리 높이)가 낮은 집합을 높은 집합 밑으로 붙임**
* 두 루트의 랭크가 같으면, 한 쪽을 루트로 만들고 그 랭크를 +1 증가

> 이 두 최적화(`랭크 기반 합치기` + `경로 압축`)를 함께 쓰면
> **모든 연산의 시간복잡도 ≒ O(α(n))** (거의 상수 시간)


